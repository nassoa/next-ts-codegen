import { compile } from 'handlebars';
import { writeFile } from 'fs/promises';
import { z } from 'zod';

import { HookGeneratorOptions as BaseHookGeneratorOptions } from '../types';

export interface HookGeneratorOptions extends BaseHookGeneratorOptions {
  // L'interface est maintenant étendue depuis le fichier de types principal
}

// Template pour les hooks SWR
const swrHookTemplate = compile(`import useSWR from 'swr';
import { {{typeName}} } from '{{typesImportPath}}';

const API_BASE_URL = '/api/{{lowercase typeName}}';

export function use{{pascalCase typeName}}() {
  return useSWR<{{typeName}}[]>(API_BASE_URL);
}

export function use{{pascalCase typeName}}ById(id: string) {
  return useSWR<{{typeName}}>(\`\${API_BASE_URL}/\${id}\`);
}

export async function create{{pascalCase typeName}}(data: Omit<{{typeName}}, 'id'>) {
  const response = await fetch(API_BASE_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  return response.json();
}

export async function update{{pascalCase typeName}}(id: string, data: Partial<{{typeName}}>) {
  const response = await fetch(\`\${API_BASE_URL}/\${id}\`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  return response.json();
}

export async function delete{{pascalCase typeName}}(id: string) {
  const response = await fetch(\`\${API_BASE_URL}/\${id}\`, {
    method: 'DELETE',
  });
  return response.json();
}
`);

// Template pour les hooks React Query
const reactQueryHookTemplate = compile(`import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { {{typeName}} } from '{{typesImportPath}}';

const API_BASE_URL = '/api/{{lowercase typeName}}';

const fetch{{pascalCase typeName}} = async (): Promise<{{typeName}}[]> => {
  const response = await fetch(API_BASE_URL);
  return response.json();
};

export function use{{pascalCase typeName}}() {
  return useQuery<{{typeName}}[], Error>({
    queryKey: ['{{lowercase typeName}}'],
    queryFn: fetch{{pascalCase typeName}},
  });
}

export function use{{pascalCase typeName}}ById(id: string) {
  return useQuery<{{typeName}}, Error>({
    queryKey: ['{{lowercase typeName}}', id],
    queryFn: async () => {
      const response = await fetch(\`\${API_BASE_URL}/\${id}\`);
      return response.json();
    },
  });
}

export function useCreate{{pascalCase typeName}}() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (data: Omit<{{typeName}}, 'id'>) => {
      const response = await fetch(API_BASE_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['{{lowercase typeName}}'] });
    },
  });
}

export function useUpdate{{pascalCase typeName}}() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ id, ...data }: { id: string } & Partial<{{typeName}}>) => {
      const response = await fetch(\`\${API_BASE_URL}/\${id}\`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['{{lowercase typeName}}'] });
    },
  });
}

export function useDelete{{pascalCase typeName}}() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: string) => {
      const response = await fetch(\`\${API_BASE_URL}/\${id}\`, {
        method: 'DELETE',
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['{{lowercase typeName}}'] });
    },
  });
}
`);

export async function generateHooks(
  data: any,
  options: HookGeneratorOptions
): Promise<void> {
  try {
    // Extraire le typeName des données ou utiliser une valeur par défaut
    const typeName = data.typeName || 'ApiResponse';
    
    // Helper functions for templates
    const helpers = {
      lowercase: (str: string) => str.toLowerCase(),
      pascalCase: (str: string) => 
        str
          .replace(/[^\w\s]/g, ' ')
          .split(/\s+/)
          .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
          .join('')
    };
    
    // Generate SWR hooks if requested
    if (options.useSwr) {
      const swrHooks = swrHookTemplate({ 
        ...data,
        ...helpers,
        typeName 
      });
      
      await writeFile(
        `${options.outputDir}/use${typeName}.swr.ts`,
        `// Generated by next-ts-codegen. DO NOT EDIT!\n\n${swrHooks}`,
        'utf-8'
      );
    }
    
    // Generate React Query hooks if requested
    if (options.useReactQuery) {
      const templateData = { 
        ...data,
        ...helpers,
        typeName,
        typesImportPath: options.typesImportPath || `./${typeName}.types`
      };
      
      const reactQueryHooks = reactQueryHookTemplate(templateData);
      
      await writeFile(
        `${options.outputDir}/use${typeName}.react-query.ts`,
        `// Generated by next-ts-codegen. DO NOT EDIT!\n\n${reactQueryHooks}`,
        'utf-8'
      );
    }
    
  } catch (error) {
    console.error('Error generating hooks:', error);
    throw error;
  }
}

export default generateHooks;
