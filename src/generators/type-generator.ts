import { compile } from 'handlebars';
import { writeFile, mkdir } from 'fs/promises';
import { dirname } from 'path';
import { compile as compileSchema } from 'json-schema-to-typescript';
import { z } from 'zod';

export interface TypeGeneratorOptions {
  outputDir: string;
  generateZodSchemas?: boolean;
  schemasDir?: string | null;
}

// Template pour les types TypeScript
const typeTemplate = compile(`{{#if description}}/** {{description}} */
{{/if}}export interface {{name}} {
{{#each properties}}
  {{#if description}}  /** {{description}} */
  {{/if}}  {{@key}}{{#unless required}}?{{/unless}}: {{type}};
{{/each}}
}
`);

export async function generateTypes(
  data: any,
  options: TypeGeneratorOptions
): Promise<string> {
  try {
    const { typeName, schema } = data;
    
    // Créer le répertoire de sortie s'il n'existe pas
    await mkdir(options.outputDir, { recursive: true });
    
    // Générer le code TypeScript à partir du schéma JSON
    const typeScriptCode = await compileSchema(schema, typeName, {
      bannerComment: '// Generated by next-ts-codegen. DO NOT EDIT!\n',
      style: {
        singleQuote: true,
        semi: true,
        tabWidth: 2,
      } as any,
    });
    
    // Écrire le fichier de types
    const typesFilePath = `${options.outputDir}/${typeName}.types.ts`;
    await writeFile(typesFilePath, typeScriptCode, 'utf-8');
    
    // Générer les schémas Zod si demandé
    if (options.generateZodSchemas && options.schemasDir) {
      await generateZodSchemas(typeName, schema, options.schemasDir);
    }
    
    return typeScriptCode;
  } catch (error) {
    console.error('Error generating types:', error);
    throw error;
  }
}

async function generateZodSchemas(
  typeName: string,
  schema: any,
  outputDir: string
): Promise<void> {
  try {
    // Créer un schéma Zod basique
    let zodSchema = 'import { z } from \'zod\';\n\n';
    
    // Convertir le schéma JSON en schéma Zod
    const zodType = jsonSchemaToZod(schema);
    
    // Ajouter le schéma d'export
    zodSchema += `export const ${typeName}Schema = ${zodType};\n`;
    zodSchema += `export type ${typeName} = z.infer<typeof ${typeName}Schema>;\n`;
    
    // Écrire le fichier de schémas Zod
    const zodFilePath = `${outputDir}/${typeName}.schema.ts`;
    await writeFile(zodFilePath, zodSchema, 'utf-8');
  } catch (error) {
    console.error('Error generating Zod schemas:', error);
    throw error;
  }
}

function jsonSchemaToZod(schema: any): string {
  if (!schema) return 'z.any()';
  
  switch (schema.type) {
    case 'string':
      return 'z.string()';
    case 'number':
    case 'integer':
      return 'z.number()';
    case 'boolean':
      return 'z.boolean()';
    case 'null':
      return 'z.null()';
    case 'array':
      return `z.array(${jsonSchemaToZod(schema.items)})`;
    case 'object':
      if (schema.properties) {
        const properties = Object.entries(schema.properties)
          .map(([key, value]) => `  ${key}: ${jsonSchemaToZod(value)}`)
          .join(',\n');
        return `z.object({\n${properties}\n})`;
      }
      return 'z.record(z.any())';
    default:
      return 'z.any()';
  }
}

export default generateTypes;
